<h1>Front-end</h1><div>The CMS's front-end is written is a framework of JavaScript, CSS and Mara template system.</div><div>It's written in CoffeeScript and Stylus. The source code can be found in the /source directory.</div><div><br></div><div>In the web environment, the compiled code is in /cms directory.</div><div>The CMS system requires the back-end system (/api).<br></div><div><br></div><div>The Mara template system is a temple system to minimize and optimize the html markup. It's better explained in the next Template section.</div><div><br></div><div>It was build to be a set of components and behaviors for HTML markups.</div><div>Usually, the having the HTML markup with necessary data (markups and attributes) inside it would suffice, but sometimes it makes use of Mara which stores the data sent by the Back-end into the HTMLElement instance.</div><div><br></div><div>The system uses HTML's query selectors to parse and find the associated components and behaviors to each HTML element.</div><div>In the source-code you can note that theres always a <b>@SELECTOR</b>&nbsp;static variable in the classes, which specifies the query selector to be used.</div><div><br></div><div>All components and behavior codes are inside <b>/cms/ui</b> source directory.</div><h3>Components</h3><div>The components are usually HTML markups.</div><div>In the source code, the components are inside <b>/cms/ui/tags</b> directory.</div><div><br></div><div>Let's take a look for instance at the <b>/cms/ui/tags/Tooltip.coffee</b> class.</div><pre>#namespace cms.ui.tags
#import slikland.utils.MouseUtils
class Tooltip extends cms.ui.Base
	@SELECTOR: 'tooltip'
	_update:(data)-&gt;
		for item in data.add
			@_plugins[item] = new Plugin(item)

		for item in data.remove
			p = @_plugins[item]
			if p
				p.destroy?()

	class Plugin extends BaseDOM
		@_destroyPlugin:(item)-&gt;

		constructor:(element)-&gt;
			super({element: element})
			@_parent = element.parentNode
			@_parent.on('mouseover', @_over)
			@_parent.on('mouseout', @_out)
		_over:()=&gt;
			@addClass('show')
		_out:()=&gt;
			@removeClass('show')
</pre><div>Firstly, as defined in the <b>@SELECTOR</b> variable, it looks for <b>&lt;tooltip&gt;</b> tags in the HTML document once the page is rendered.<br></div><div>Every update on the DOM structure, the system parses the DOM structure to find what <b>HTMLElements</b>&nbsp;were changed and calls the <b>_update</b>&nbsp;method for each component with information of which <b>HTMLElements</b>&nbsp;were added, removed, unchanged and the currently available.</div><h3>Behaviors</h3><div>Behaviors are usually <b>HTMLElement</b>&nbsp;attributes. It doesn't really need to be a specific component although has a unique behavior.</div><div>The code structure are identical to the Components, it's separated mostly for organizational reasons.</div><div>It's code are in <b>/cms/ui/attributes/</b>&nbsp;directory.</div><div><br></div><div><b>/cms/ui/attributes/Href.coffee</b></div><pre>#namespace cms.ui.tag.attributes
class Href extends cms.ui.Base
	@SELECTOR: '[href]'
	_update:(data)-&gt;
		for item in data.add
			if item.hasAttribute('href') &amp;&amp; !item.getAttribute('target')
				@_plugins[item] = new Plugin(item)
		for item in data.remove
			p = @_plugins[item]
			if p
				p.destroy?()

	class Plugin extends BaseDOM
		@_destroyPlugin:(item)-&gt;

		constructor:(element)-&gt;
			super({element: element})
			@_element.on('click', @_click)
		_click:(e)=&gt;
			app.router.goto(@attr('href'))
			e.preventDefault()
			e.stopImmediatePropagation()
</pre><div>As you can see in the above example, it looks for any <b>HTMLElement</b>&nbsp;that has the <b>href</b>&nbsp;attribute, and it will handle it's click and will use internal router controller to change pages.</div><div><br></div><h3>Templates</h3><div>The templates for the CMS are inside /cms/templates directory.</div><div>Inside it, the /pages directory are the templates for every page in CMS.</div><h2>The flow</h2><div>To understand better here's how the CMS works.</div><div><ol><li>Loads the /templates/pages/index.mara template from PHP (cms/index.php)</li><li>Add DOM change watcher. Any change in the DOM structure will update the components and behaviors.</li><li>Add History pushState listener to control the navigation.</li><li>Verifies if user is logged. If not sends to the login screen (/templates/user/login.mara)</li><li>Loads interface data to build the menu navigation and the main container where the pages are rendered.</li><li>When navigation changes, it loads the associated page template and renders it in the main container.</li></ol>The CMS system only controls the data requests to the Back-end of user authentication.</div><div>The CMS pages does not contain any dynamic (back-end) data, meaning, the templates are rendered statically without any data. The only data associated when rendering the CMS system are global objects that are stored in the global <b>app</b>&nbsp;variable and the <b>routeData</b>.</div><div>The <b>app</b> data can be accessed using atmark @: {@user.id}</div><div>routeData can be accessed using dollar sign $: {$[id]} // http://something/cms/test?id=1</div><div><br></div><div>Once the page is rendered, the <b>Service</b>&nbsp;behavior takes care of loading the back-end data.</div><div>This way, each component will load it's data asynchronously after the page is rendered.</div><div>With this approach, every component works independently, and also allows to be updated on the run independently without reloading the entire page.</div><div><br></div>