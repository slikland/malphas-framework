#import slikland.anim.BaseAnimation
#import slikland.display.BaseDOM
class SpriteSheetAnimation extends BaseAnimation

	@_init:()->
		head = document.querySelector("head") || document.getElementsByTagName("head")[0]
		css = '.animation.spritesheet{display: inline-block;position: relative;font-size:0px;}'
		style = document.createElement('style')
		style.type = "text/css"
		head.appendChild(style)
		si = head.querySelectorAll('style').length

		try
			style.appendChild(document.createTextNode(css))
		catch e
			if document.all
				document.styleSheets[si].cssText = css

	@_init()
	###*
	Spritesheet Animation class

	This class will animate a spritesheet. It already handles responsiveness.<br>
	So If the size of the SpriteSheetAnimation div is set, the animation will fit in the defined size.<br>
	If a size is not set, it'll use the size defined in the JSON object.

	@class SpriteSheetAnimation
	@constructor
	@extends BaseAnimation
	@param {Object} data Object defining spritesheet.

	The Spritesheet image and json needs to be generated by Adobe Flash.<br>
	It also accepts *trim* and *border* parameters set when exporting the Spritesheet from Adobe Flash.

	Name |Type|Default|Description
	-----|----|:------|-----------
	image|Image|null|Image of spritesheet. It can either be a Image Element or PreloadJS image loader, which gives *data.tag* as image.
	json|Object|null|JSON object defining the spritesheet. It can either be an Object or PreloadJS json loader, which gives *data.tag* as object.
	useBackground|Bool|false|Boolean indicating if the Spritesheet Animation should use as background-image or a image element. Default is **false**. It's safer using an Image element instead of background-image for cross-browser integration.

	@example
	```
	spritesheet = new SpriteSheetAnimation({image: someImage, json: someJson});
	document.body.appendChild(spritesheet.element);
	sprithesheet.play({repeat: false});
	```
	###
	constructor:(data)->
		if !data.image?
			throw new Error('data.image is not set')
		if !(data.json)
			throw new Error('data.json is not set')
		image = data.image.tag || data.image
		json = data.json.tag || data.json

		if !(image instanceof Image || image.tagName?.toLowerCase() == 'img')
			throw new Error('data.image is not Type of Image')

		super
		@addClass('spritesheet')
		
		@_useBackground = data.background || false
		@_frames = @_parseJson(json)
		@_totalFrames = @_frames.length

		@_holder = new BaseDOM({element: 'div'})
		@_holder.css({
			display: 'inline-block'
			width: @_size.w + 'px'
			height: @_size.h + 'px'
		})
		@appendChild(@_holder)

		@_container = new BaseDOM({element: 'div'})
		@_container.css({
			display: 'inline-block'
			position: 'absolute'
			overflow: 'hidden'
		})
		@appendChild(@_container)

		if @_useBackground
			@_setupBackground(image)
			@_redraw = @_redrawBackground
		else
			@_setupImage(image)
			@_redraw = @_redrawImage

	_parseJson:(data)->
		frames = []
		@_imageSize = data.meta.size
		trimmed = false
		maxWidth = Number.MIN_VALUE
		maxHeight = Number.MIN_VALUE
		i = 0
		for f in data.frames
			sw = f.sourceSize.w
			sh = f.sourceSize.h
			isw = 1 / sw
			ish = 1 / sh
			fo = {}
			fo.source = f.frame
			if @_useBackground
				fo.proportionalSource = {x: ((f.frame.x / (@_imageSize.w - f.frame.w)) * 100).toString() + '%', y: ((f.frame.y / (@_imageSize.h - f.frame.h)) * 100).toString() + '%', w: ((@_imageSize.w / f.frame.w) * 100).toString() + '%', h: ((@_imageSize.h / f.frame.h) * 100).toString() + '%'}
			else
				fo.proportionalSource = {x: (-(f.frame.x / f.frame.w) * 100).toString() + '%', y: (-(f.frame.y / f.frame.h) * 100).toString() + '%', w: ((@_imageSize.w / f.frame.w) * 100).toString() + '%', h: ((@_imageSize.h / f.frame.h) * 100).toString() + '%'}
			fo.output = {x: f.spriteSourceSize.x, y: f.spriteSourceSize.y, w: f.frame.w, h: f.frame.h}
			fo.proportionalOutput = {x: f.spriteSourceSize.x * isw, y: f.spriteSourceSize.y * ish, w: f.frame.w * isw, h: f.frame.h * ish}
			if maxWidth < sw
				maxWidth = sw
			if maxHeight < sh
				maxHeight = sh
			frames[i++] = fo
		@_size = {w: maxWidth, h: maxHeight}
		i = frames.length
		while i-- > 0
			fo = frames[i]
			fo.output.x = ((fo.output.x / maxWidth) * 100).toString() + '%'
			fo.output.y = ((fo.output.y / maxHeight) * 100).toString() + '%'
			fo.output.w = ((fo.output.w / maxWidth) * 100).toString() + '%'
			fo.output.h = ((fo.output.h / maxHeight) * 100).toString() + '%'
		return frames

	_setupImage:(image)->
		@_image = image.cloneNode()
		@_image.style.position = 'absolute'
		@_image.style.display = 'inline-block'
		@_image.style.width = (@_imageSize.w / @_size.w) * 100 + '%'
		@_image.style.height = (@_imageSize.h / @_size.h) * 100 + '%'
		@_container.appendChild(@_image)
	_setupBackground:(image)->
		@_container.css({
			'background-image': 'url(' + image.src + ')'
		})

	_redrawImage:()=>
		fd = @_frames[@_currentFrame]
		if !fd
			return
		@_container.css({
			left: fd.output.x
			top: fd.output.y
			width: fd.output.w
			height: fd.output.h
		})

		@_image.style['left'] = fd.proportionalSource.x
		@_image.style['top'] = fd.proportionalSource.y
		@_image.style['width'] = fd.proportionalSource.w
		@_image.style['height'] = fd.proportionalSource.h

	_redrawBackground:()=>
		fd = @_frames[@_currentFrame]
		if !fd
			return
		@_container.css({
			left: fd.output.x
			top: fd.output.y
			width: fd.output.w
			height: fd.output.h
			backgroundSize: fd.proportionalSource.w + ' ' + fd.proportionalSource.h
			backgroundPosition: fd.proportionalSource.x + ' ' + fd.proportionalSource.y
		})
